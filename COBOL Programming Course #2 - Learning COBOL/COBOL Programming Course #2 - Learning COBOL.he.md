---
geometry:
- margin=1in
header-includes:
- \lstset{basicstyle=\ttfamily,
    stepnumber=2,
    numbersep=5pt,
    backgroundcolor=\color{black!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=true,
    breakautoindent=true,
    linewidth=\textwidth}
colorlinks: true
toccolor: Blue
---
\newpage

# למה COBOL?

הפרק הזה מציג את שפת COBOL, במיוחד בהקשר של השימוש שלה במערכות ארגוניות.

- **מהי COBOL?**

- **איך משתמשים ב-COBOL היום?**

- **אילו תובנות מסקר צוות עבודה של Open Mainframe Project על COBOL מספק?**

- **למה כדאי לי להביא בחשבון את COBOL?**

## מהי COBOL?

שפת תכנות אחת נוצרה במיוחד לעסקים — Common Business-Oriented Language, הידועה כ-COBOL. מאז המצאתה ב-1959, COBOL משנה ותומכת בתהליכי עסקים ברחבי העולם. COBOL אחראית על הפעולה היומיומית, היעילה, האמינה והמאובטחת של חלק גדול מהכלכלה העולמית. הלוגיקה היומיומית שמשמשת לעיבוד נתונים קריטיים נעשית לעיתים קרובות באמצעות COBOL.

רבות מתוכניות ה-COBOL תוחזקו והשתפרו במשך עשרות שנים — הכולל לוגיקת עסק, שיפורי ביצועים, פרדיגמות תכנות, וממשקי תוכנה (APIs) למעבדי עסקאות, מקורות נתונים ואינטרנט.

מאות שפות תכנות פותחו ב-60 השנים האחרונות וצפו לשנות את נוף ה-IT. חלקן, כמו C, C++, Java ו-JavaScript, אכן שינו אותו. עם זאת, COBOL ממשיכה להתבלט בזכות יכולתה הטבעית לטפל בכמויות עצומות של נתונים קריטיים המאוחסנים על שרתים גדולים כמו IBM Z (מיינפריים).

בתיקונים ועדכונים רצופים שנועדו לכלול פרדיגמות תכנות מודרניות ושיטות עבודה מוכחות, COBOL תישאר שפת תכנות קריטית בעתיד הנראה לעין. למידת COBOL מאפשרת קריאה והבנה של אופן הפעולה היומיומי של מערכות קריטיות. ידע ומיומנות ב-COBOL הוא מיומנות נדרשת להיות "מפתח full-stack" בארגונים גדולים.

## איך משתמשים ב-COBOL היום?

COBOL נמצאת בכל מקום, וסביר מאוד שפגשת היום אפליקציה שמשתמשת ב-COBOL. להלן כמה סטטיסטיקות מרשימות:

- כ-95% מעסקאות כספומט (ATM) מסתמכות על קוד COBOL.
- COBOL מפעילה 80% מהעסקאות פנים-אל-פנים.
- מדי יום מערכות COBOL מקלות על מסחר בהיקף של כ-3 טריליון דולר.

להבין את השכיחות של COBOL אפשר גם לראות נתונים מפתיעים נוספים:

- מדי יום מבוצעות פי 200 פעמים יותר עסקאות COBOL מאשר חיפושים בגוגל.
- כיום יש מעל 250 מיליארד שורות קוד COBOL פעילות, מה שמייצג כ-80% מהקוד הפעיל בעולם.
- בכל שנה נכתבות כ-1.5 מיליארד שורות קוד COBOL חדשות.

## אילו תובנות מספק הסקר של Open Mainframe Project's COBOL Working Group?

ממצאים מרכזיים מסקר שנערך על-ידי קבוצת העבודה ל-COBOL במסגרת Open Mainframe Project בשנת 2021 מבהירים עוד יותר את השימוש ב-COBOL בעידן הנוכחי:

1. **יותר מ-250 מיליארד שורות COBOL נמצאות כיום בפרודקשן ברחבי העולם**, עלייה מהערכות קודמות. זה מעיד שמתייחס ל-COBOL כאל טכנולוגיה עם חשיבות מתמשכת.

   הענפים שמסתמכים ביותר על COBOL כוללים שירותים פיננסיים, ממשל, תוכנה, לוגיסטיקה, קמעונאות וייצור, בין היתר.

2. **עתיד COBOL נראה מבטיח**. למרות הספקנים, 58% מהמשתתפים בסקר צופים שאפליקציות COBOL שלהם יתמידו לפחות חמש השנים הקרובות. אנשי שירותים פיננסיים אף אופטימיים יותר — מעל 55% צופים ש-COBOL תישאר לנצח.

3. **האתגר הוא בזמינות מיומנויות COBOL**. בהיותה שפה שתוכננה להיות נגישה וללא צורך במומחיות מחשוב גבוהה, חברות מודאגות מחוסר מתכנתי COBOL מיומנים. אמנם ניתן להכשיר עובדים פנימיים, אך הדאגה הזו מדגישה ש-COBOL עדיין חשובה וראויה להשקעה.

## למה כדאי לי להתעניין ב-COBOL?

שפת COBOL, אופטימיזציות קומפיילר וביצועי זמן ריצה צברו מעל 50 שנות שיפורים שהן בסיס לכלכלה העולמית. לוגיקת הליבה העסקית של ארגונים גדולים הוטמעה במשך עשרות שנים בתוך תוכניות COBOL.

בקיצור — כל מה שתשמע על COBOL שים אליו ספק. אם יש לך הזדמנות לעבוד לצד מישהו שמעורב בכתיבה או תחזוקה של לוגיקה עסקית קריטית ב-COBOL, תלמד איך העסק עובד באמת. מנהלי עסקים ואנליסטים באים והולכים, ואוסף ההחלטות העסקיות הטובות נמצא לעתים קרובות בשינויים המיושמים במשך שנים בקודי COBOL. התשובה לשאלה "איך העסק עובד בפועל?" תמצא לעתים קרובות בקוד COBOL.

הנה עוד נקודה חשובה: מיתוס מוחלט הוא שאי אפשר להיות טובים ב-COBOL בלי להיות מעל גיל 50. COBOL קלה מאוד ללמידה ולהבנה. אחד הסיבות שבגללן מוסדות פיננסיים אוהבים את COBOL הוא שלא חייבים להיות מתכנת כדי לקרוא ולהבין את הלוגיקה. זה חשוב כי קוד לוגיקה עסקי קריטי נתון לביקורת — ומבקרי חשבונות אינם מתכנתים. עם זאת הם אחראים לוודא שהדוחות הכספיים מוצגים באופן הוגן — לעתים קרובות עיבוד COBOL הוא זה שמעדכן את ספרי החשבונות ומייצר דוחות פיננסיים.

דוגמה מהעולם האמיתי: טענה במגזין עסקי שצוטטה כך: "COBOL היא שפת חישוב ישנה ואיטית, נוצרה ב-1959" — העובדה היחידה הנכונה במשפט היתה שנת היצירה, 1959. כשמסתכלים על המציאות, הרבה בנקים עדיין מריצים מיליוני שורות COBOL על מיינפריימים. הם יתכן וישמחו להחליף זאת בעתיד, אבל למה הם לא החליפו? לרוב הבנקים יש מערכות ליבה יציבות, מתוחות ונבדקות היטב שנבנו במשך עשרות שנים — החלפתן עלולה להיות יקרה ומסוכנת. לכן לעיתים עדיף לשמר מערכת רצה אלא אם יש סיבות טובות מאוד לשנות.

כיום יש שכבות מודרניות כמו ממשקי Java ו-wrapper-ים שמוסיפים פונקציונליות או ממשקים מודרניים, והרצת היישום על שרתים וירטואליים משוכפלים — אך בסופו של דבר הכל עובר דרך אותה לוגיקת ליבה שאינה משתנה אלא במקרים הכרחיים.

מנקודת מבט הנדסת תוכנה, גם זה הגיוני: שכתוב מערכות יקר יותר ומסורבל יותר מהמתוכנן — לכן לעתים קרובות לא שמים עליו יד.

\newpage

# Basic COBOL

פרק זה מציג את יסודות תחביר COBOL, ואז מראה כיצד לצפות ולהריץ תוכנית COBOL בסיסית ב-VS Code.

- **מאפייני COBOL**
     - **Enterprise COBOL**
     - **מטרות הפרק**

- **מה צריך מודל מתחיל ב-COBOL לדעת כדי להיות מפתח COBOL מנוסה?**
     - **חוקי קידוד ותבנית-reference**
     - **מהי מבנה COBOL?**
     - **מהם מילים שמורות של COBOL?**
     - **מהו משפט COBOL?**
     - **מה משמעות מסמן תחום (scope terminator)?**
     - **מהי משפט (sentence) ב-COBOL?**
     - **מהי פסקה (paragraph) ב-COBOL?**
     - **מהו סעיף (section) ב-COBOL?**
     - **איך להריץ תוכנית COBOL על z/OS?**

- **מחלקות COBOL (Divisions)**
     - **מבנה מחלקות COBOL**
     - **מהן ארבע מחלקות ה-COBOL?**


- **הסבר על PROCEDURE DIVISION**

- **מידע נוסף**
     - **מדריכים מקצועיים**
     - **למידע על חידושים ב-COBOL**

- **מעבדה**

- **מעבדה - Zowe CLI ואוטומציה**
    - **Zowe CLI - שימוש אינטראקטיבי**
    - **Zowe CLI - שימוש פרוגרמטי**


## מאפייני COBOL

COBOL היא שפה דמוית-אנגלית שמקלה על קריאת, הבנת ותחזוק קוד המקור. למידת תכנות ב-COBOL כוללת ידע בחוקי קוד המקור, מילות שמורות, מבנה COBOL ויכולת לאתר ולפרש תיעוד מקצועי. מאפיינים אלה חשובים כדי להיות מיומן בקריאה, כתיבה ותחזוקה של תוכניות COBOL.

### Enterprise COBOL

COBOL היא תקן ואינה בבעלות אף חברה. "Enterprise COBOL" הוא השם לגרסה של COBOL שמורכבת ומריצים בסביבת IBM Z (z/OS). ההסברים בהמשך חלים על Enterprise COBOL.

Enterprise COBOL צברה עשרות שנים של שיפורים — פונקציות חדשות, הרחבות יכולת, שיפורי ביצועים, APIs וכו'. היא עובדת עם טכנולוגיות תשתית מודרניות ותומכת באופן טבעי ב-JSON, XML ו-Java®.

### מטרות הפרק

מטרת פרק זה לחשוף את הקורא למונחי COBOL, חוקי קידוד ותחביר; השאר יכנס לעומק ויכלול מעבדות לתרגול.

## מה חייב מתכנת מתחיל ב-COBOL לדעת כדי להיות מתכנת מנוסה?

הקטע הבא נותן מידע שיסייע להעמקת ההבנה של השאלות והתשובות בפרקים הבאים.

### מהו חוקי קידוד ותבנית-reference?

קוד מקור של COBOL תלוי בעמודות — יש כללים על עמדות עמודה. כל שורה בקוד מחולקת לחמישה אזורים, לכל אזור יש עמודת התחלה וסוף.

טקסט המקור חייב להיות ב-COBOL reference format (72 תווים שורה).

![פורמט-reference של COBOL](Images/image033.jpg "איור 1: פורמט-reference של COBOL")

*איור 1. פורמט-reference של COBOL*

פורמט ה-reference מפורט כך:

#### אזור מספר רצף (עמודות 1 - 6)

- ריק או שמור למספרי שורות.

#### אזור אינדיקטור (עמודה 7)

- אזור רב-תכליתי:

    - שורת הערה (בדרך כלל כוכבית)

    - שורת המשך (בדרך כלל מקף)

    - שורת דיבאג (D או d)

    - עיצוב רשימת מקור (סלאש)

#### אזור A (עמודות 8 - 11)

- פריטים מסוימים חייבים להתחיל באזור A, כגון:

    - אינדיקטורי רמה

    - DECLARATIVE

    - כותרות Division, Section, Paragraph

    - שמות פסקאות

- עמודה 8 נקראת A Margin

#### אזור B (עמודות 12 - 72)

- פריטים מסוימים חייבים להתחיל באזור B, כגון:

    - משפטים, ציטוטים, הוראות

    - שורות המשך

- עמודה 12 נקראת B Margin

#### אזור זיהוי (עמודות 73 - 80)

- מוזנח על-ידי הקומפיילר.

- יכול להיות ריק או שימושי על-ידי המתכנת לכל מטרה.

### מהו מבנה COBOL?

מבנה הירארכי מלמעלה למטה:

- Divisions

- Sections

- Paragraphs

- Sentences

- Statements

### מהן מילות שמורות ב-COBOL?

ל-COBOL יש מילים עם משמעות מיוחדת לקומפיילר — מילות שמורות. אין להשתמש בהן כשמות משתנים.

כמה דוגמאות הרלוונטיות לספר זה: PERFORM, MOVE, COMPUTE, IF, THEN, ELSE, EVALUATE, PICTURE, וכו'.
קישור למילות שמורות מלאות:

[https://www.ibm.com/docs/en/cobol-zos/6.4?topic=appendixes-reserved-words](https://www.ibm.com/docs/en/cobol-zos/6.4?topic=appendixes-reserved-words)

### מהו משפט (statement) ב-COBOL?

מילות שמורות מסוימות משנות את זרימת הביצוע בתוכנית. "Statements" קיימים רק ב-PROCEDURE DIVISION — שם מבוצעת הלוגיקה. דוגמאות: IF, EVALUATE, PERFORM.

### מהו מסמן תחום (scope terminator)?

מסמן התחום יכול להיות מפורש או משתמע. מסמן מפורש מסיים משפטים מסוימים באמצעות מילת שמורה "END-". מסמן משתמע הוא נקודה (.) שמסיימת את טווח כל המשפטים שלא נסגרו.

### מהו sentence ב-COBOL?

"Sentence" ב-COBOL הוא משפט אחד או יותר המסתיים בנקודה (.) — הנקודה משמשת כסיום טווח.

### מהי paragraph ב-COBOL?

"Paragraph" הוא שם משתמש (או מוגדר מראש) המסתיים בנקודה. פסקה מכילה אפס או יותר משפטים והיא תת-חלוקה של Section או Division.

![דוגמה: Division -> paragraph -> sentences](Images/image003.png "דוגמה: Division -> paragraph -> sentences")

*דוגמה 1. Division -> paragraph -> sentences*

### מהי section ב-COBOL?

"Section" הוא שם (מוגדר או משתמש) המסתיים בנקודה ומכיל אפס או יותר משפטים — אוסף פסקאות.

### איך להריץ תוכנית COBOL על z/OS?

ב-z/OS תיתקל ב-JCL — Job Control Language. JCL מכיל הוראות ל-z/OS מה להריץ ומהן קבוצות הקלט/פלט.

על מנת לייצר ריצת תוכנית יש להדריך את מערכת ההפעלה לקמפל ול-Link-edit את הקוד — הכל באמצעות JCL.

Enterprise COBOL מספקת שלושה נהלים (procedures) ב-JCL שיכולים לפשט את התהליך:

1. IGYWC — סתם "compile".
2. IGYWCL — compile + link-edit.
3. IGYWCLG — compile + link-edit + run.

בקורס זה, ה-JCL הדרוש למעבדות מסופק עבורך — פשוט העתק/שנה כרצונך.

למידע נוסף על JCL:

[https://www.ibm.com/docs/en/zos-basic-skills?topic=collection-basic-jcl-concepts](https://www.ibm.com/docs/en/zos-basic-skills?topic=collection-basic-jcl-concepts)

## Divisions של COBOL

חלק זה מציג את ארבעת ה-Divisions בקצרה ותפקידן.

### מבנה ה-Divisions

Divisions מחולקות ל-Sections; Sections לפסקאות; פסקאות למשפטים; משפטים מורכבים מ-Statements.

### מהן ארבעת ה-Divisions?

#### IDENTIFICATION DIVISION

מזהה את התוכנית בשם ומידע אופציונלי — מחבר, תאריך קומפילציה וכו'.

#### ENVIRONMENT DIVISION

מתאר את ההיבטים התלויים בסביבת החישוב — קונפיגורציית מחשב, כניסות/יציאות.

#### DATA DIVISION

כאן מוגדרים מאפייני הנתונים באחד מהסעיפים:

- FILE SECTION — נתונים ל-I/O.
- LINKAGE SECTION — נתונים המתקבלים מתוכנית אחרת.
- WORKING-STORAGE SECTION — זיכרון לכל חיי התוכנית.
- LOCAL-STORAGE SECTION — זיכרון שמוקצה בכל קריאה ומתפנה בסיום.

#### PROCEDURE DIVISION

מכיל הוראות לעיבוד הנתונים וממשקי קריאות לפרוצדורות אחרות.

## הסבר על PROCEDURE DIVISION

PROCEDURE DIVISION הוא המקום שבו העבודה נעשית — Statements הם פעולות שמבוצעות ע"י התוכנית. ה-PROCEDURE DIVISION נחוצה כדי לעבד נתונים. היא מחולקת ל-Sections ופסקאות.

- **Section** — תת-חלוקה לוגית של לוגיקת עיבוד. יכולה להכיל כותרת ואחת או יותר פסקאות. חלק מסוג זה הוא DECLARATIVES שמוגדר בתחילת ה-PROCEDURE DIVISION ומסתיים ב-END DECLARATIVES.

- **Paragraph** — תת-חלוקה של Section; ניתן לקרוא לה באמצעות PERFORM.

- **Sentence** — סדרה של Statements המסתיימת בנקודה.

- **Statement** — פעולה שהמחשב יבצע.

- **Phrase** — חלק קטן של Statement, כמו שם תואר באנגלית.

## מידע נוסף

משאבים שימושיים למדריכים מקצועיים וללמידה מתקדמת זמינים באינטרנט: ספריות תיעוד Enterprise COBOL, Programming Guide ו-Messages and Codes (קישורים בהמשך).

### מדריכים מקצועיים

מידע נוסף באתר IBM Enterprise COBOL documentation (V6.4 נכון לדצמבר 2022):

[https://www.ibm.com/support/pages/enterprise-cobol-zos-documentation-library](https://www.ibm.com/support/pages/enterprise-cobol-zos-documentation-library)

מדריכים עיקריים המצוינים בפרקים:

1. Language Reference — מתאר את שפת COBOL (מבנה, מילות שמורות וכו').
   [https://publibfp.dhe.ibm.com/epubs/pdf/igy6lr40.pdf](https://publibfp.dhe.ibm.com/epubs/pdf/igy6lr40.pdf)

2. Programming Guide — נושאים מתקדמים כגון אפשרויות קומפילר, ביצועים, טיפול בשגיאות.
   [https://publibfp.dhe.ibm.com/epubs/pdf/igy6pg40.pdf](https://publibfp.dhe.ibm.com/epubs/pdf/igy6pg40.pdf)

3. Messages and Codes — להבנת הודעות קומפילר וקודי החזרה.
   [https://publibfp.dhe.ibm.com/epubs/pdf/c2746482.pdf](https://publibfp.dhe.ibm.com/epubs/pdf/c2746482.pdf)

### למידה על חידושים ב-COBOL

- What’s New in Enterprise COBOL for z/OS V6.1:
  [https://www.ibm.com/support/pages/cobol-v61-was-announced-whats-new](https://www.ibm.com/support/pages/cobol-v61-was-announced-whats-new)

- What’s New in Enterprise COBOL for z/OS V6.2:
  [https://www.ibm.com/support/pages/cobol-v62-was-announced-whats-new](https://www.ibm.com/support/pages/cobol-v62-was-announced-whats-new)

- What’s New in Enterprise COBOL for z/OS V6.3:
  [https://www.ibm.com/support/pages/cobol-v63-was-announced-whats-new](https://www.ibm.com/support/pages/cobol-v63-was-announced-whats-new)

- What’s New in Enterprise COBOL for z/OS V6.4:
  [https://www.ibm.com/docs/en/cobol-zos/6.4?topic=wn-what-is-new-in-enterprise-cobol-zos-64-cobol-64-ptfs-installed](https://www.ibm.com/docs/en/cobol-zos/6.4?topic=wn-what-is-new-in-enterprise-cobol-zos-64-cobol-64-ptfs-installed)

## מעבדה

במעבדה זו תתחבר למערכת IBM Z, תצפה בתוכנית COBOL פשוטה ב-VS Code, תגיש JCL לקימפול והרצה ותצפה בפלט. יש להתייחס למדור "התקנת VS Code והרחבות" במידה ולא הוגדר ה-IDE שלך. ניתן להשתמש ב-IBM Z Open Editor + Zowe Explorer, או ב-Code4z.

1. נדרש התקנת VS Code עם אחת החבילות: IBM Z Open Editor ו-Zowe Explorer, או Code4z extension pack.

   לחץ על סמל **Extensions**. אם התקנת IBM Z Open Editor ו-Zowe Explorer, הרשימה תכיל:

   1. IBM Z Open Editor
   2. Zowe Explorer

   ![תוספי VS Code: IBM Z Open Editor ו-Zowe Explorer](Images/image044.png "תוספי VS Code: IBM Z Open Editor ו-Zowe Explorer")

   *איור 2a. רשימת הרחבות — IBM Z Open Editor ו-Zowe Explorer*

   אם התקנת Code4z, הרשימה תכיל (כמה דוגמאות):

   1. COBOL Language Support
   2. Zowe Explorer
   3. Explorer for Endevor
   4. HLASM Language Support
   5. Debugger for Mainframe
   6. COBOL Control Flow
   7. Abend Analyzer for Mainframe
   8. Data Editor for Mainframe

   ![Code4z — חבילת הרחבות VS Code](Images/image044b.png "Code4z — חבילת הרחבות VS Code")

   *איור 2b. חבילת Code4z של הרחבות VS Code.*

   **הערה:** אם ברשימת התוספים מופיעים גם Z Open Editor וגם COBOL Language Support, יש להשבית אחד מהם על-ידי לחיצה על סמל ההגדרות (cog) ובחירה ב-**Disable**.

2. לחץ על סמל Zowe Explorer (הצד שמאל). Zowe Explorer מציג Data Sets, Unix System Services וקבצי Jobs.

   ![סמל Zowe Explorer](Images/image046.png "סמל Zowe Explorer")

   *איור 3. סמל Zowe Explorer*

3. כדי להתחבר למערכת המעבדה, הורד ופתח את קובץ קונפיגורציית הצוות (ZIP) מתוך מדור Releases של מאגר הקורס ב-GitHub: https://github.com/openmainframeproject/cobol-programming-course/releases/latest

   ![חלוץ: חלץ את קובץ ה-ZIP](Images/image0001.png "חלץ קובץ קונפיגורציית הצוות")

   *איור 4. חלץ את קובץ ה-ZIP*

4. פתח את התיקייה שחולצה — תמצא בתוכה שני קבצי קונפיגורציה.

   ![קבצי קונפיגורציית הצוות בתוך התיקייה](Images/image0002.png "קבצי קונפיגורציית הצוות")

   *איור 5. קבצי תצורה בתוך תיקיית הצוות*

5. בחזרה ל-VS Code, בחר את לשונית Explorer ולחץ על "Open folder" בצד השמאלי.

   ![לחיצה על כפתור Open folder ב-VS Code](Images/vscode-add-folder.png "Open folder ב-VS Code")

   *איור 6. לחץ על כפתור open folder*

6. בחלון הקופץ בחר את התיקייה שבה נמצאים קבצי תצורת הצוות (שלב 4). אם תתבקש לסמוך על מחברי הקבצים, בחר **Yes, I trust the authors**.

   ![בחר תיקיית תצורת הצוות](Images/image0003.png "בחר את תיקיית תצורת הצוות")
   ![הסכמה לסמוך על המחברים](Images/image0008.png "בטוח במחברי הקבצים — בחר Yes")

   *איור 7a ו-7b. בחירת תיקיית הקונפיג והסכמת אמון*

7. החיבור שלך אמור להופיע אוטומטית ברשימת Data Sets.

   ![התחברות LearnCOBOL ברשימת Data Sets](Images/image0004.png "חיבור LearnCOBOL")

   *איור 8a. חיבור LearnCOBOL*

   אם החיבור לא מופיע, הרחף מימין ל-Data Sets ולחץ על + כדי להוסיף את החיבור באופן ידני — בחר **LearnCOBOL**.

   ![הוספת חיבור LearnCOBOL ידנית](Images/image0005.png "הוספת LearnCOBOL")

   *איור 8b. הוספה ידנית של חיבור LearnCOBOL*

8. לחץ על החיבור LearnCOBOL.

   ![לחיצה על חיבור LearnCOBOL ברשימה](Images/image0007.png "לחיצה על LearnCOBOL")

   *איור 9. לחיצה על החיבור*

9. המערכת תבקש שם משתמש — הכנס את שם המשתמש שהוקצה לך (אל תשתמש ב-Z99998 לדוגמה).

   ![מסך בקשה לשם משתמש](Images/image061.png "בקשת שם משתמש")

   *איור 10. בקשת שם משתמש*

10. הכנס את סיסמתך כאשר תתבקש.

   ![מסך בקשת סיסמה](Images/image067.png "בקשת סיסמה")

   *איור 12. בקשת סיסמה*

11. הרחב את LearnCOBOL והשתמש בסמל זכוכית מגדלת (magnifying glass) כדי להציג Data Sets.

   ![לחיצה על סמל זכוכית מגדלת לסינון Data Sets](Images/image084.png "סמל זכוכית מגדלת לסינון")

   *איור 14. סמל הסינון*

12. חפש את מזהה המשתמש שלך (high-level qualifier) — הקלד אותו בתיבת החיפוש.

   ![הקלדת שם המשתמש כחלק מסינון Data Sets](Images/image086.png "סינון Data Sets לפי שם משתמש")

   *איור 15. חיפוש לפי שם משתמש*

13. תופיע רשימת Data Sets שמתחילות בשם המשתמש שלך; הרחב `<USERNAME>.CBL` ובחר את החייל HELLO כדי לראות תוכנית "Hello World!" פשוטה.

   ![הצגת חבר מקוד מקור HELLO ב-<USERNAME>.CBL](Images/image093.png "הצגת חבר COBOL HELLO")

   *איור 18. `<USERNAME>.CBL` — חבר HELLO*

14. הרחב `<USERNAME>.JCL` ובחר את החבר HELLO — זוהי ה-JCL שמקמפלת ומריצה את מקור HELLO.

   ![הצגת חבר JCL HELLO בתיקיית המשתמש](Images/image095.png "הצגת חבר JCL HELLO")

   *איור 19. `<USERNAME>.JCL` — HELLO JCL*

15. קליק ימני על חבר JCL -> בחר **Submit Job** לשם הרצתו. ה-JCL יקומפל ויריץ את קוד ה-COBOL.

   ![לחיצה Submit Job על חבר JCL HELLO](Images/image097.png "Submit Job")

   *איור 20. Submit Job*

16. תוכל לצפות בסעיף 'Jobs' ב-Zowe Explorer.

   ![סעיף JOBS ב-Zowe Explorer](Images/image098.png "JOBS ב-Zowe Explorer")

   *איור 21. JOBS*

17. הוסף שוב חיבור חדש לצד ה-Jobs (לחצן +) ובחר **LearnCOBOL** כדי לראות את המשרות בבעלות המשתמש.

   ![יצירת חיבור חדש ל-Jobs — בחירת LearnCOBOL](Images/image100.png "בחר LearnCOBOL לחיבור Jobs")

   *איור 22. בחירת החיבור*

18. תמצא את שם ה-JOB שנשלח — לדוגמה HELLOCBL; הרחב את הפלט שלו כדי לראות חלקים מהפלט.

   ![הרחבת פלט ה-JOB HELLOCBL](Images/image102.png "הרחב פלט HELLOCBL")

   *איור 23. פלט HELLOCBL*

19. בחר **COBRUN:SYSPRINT(101)** כדי לצפות בפלט הקומפילציה של הקוד.

   ![צפייה בפלט הקומפילציה — COBRUN:SYSPRINT(101)](Images/image104.png "צוגת פלט קומפילציה")

   *איור 24. פלט קומפילציה של COBOL*

20. בחר **COBRUN:SYSOUT(104)** כדי לצפות בהרצת התוכנית (פלט Run).

   ![צפייה בפלט הריצה — COBRUN:SYSOUT(104)](Images/image106.png "פלט הרצת התוכנית")

   *איור 25. פלט הרצת התוכנית*

21. שים לב שתצטרך לפתוח את תיקיית LearnCOBOL בכל חיבור מחדש. כדי שהפרופיל יהיה נגיש מכל מקום, העבר את `zowe.config.json` ו-`zowe.schema.json` למיקום הגלובלי של Zowe:

   - Windows: `C:\Users\%USERNAME%\\.zowe`
   - Linux/macOS: `~/.zowe`

22. עוד משאב טוב על VS Code ו-Zowe Explorer:

[https://marketplace.visualstudio.com/items?itemName=Zowe.vscode-extension-for-zowe](https://marketplace.visualstudio.com/items?itemName=Zowe.vscode-extension-for-zowe)

## מעבדה - Zowe CLI ואוטומציה

במעבדה זו תשתמש ב-Zowe CLI לאוטומציה של הגשת JCL, הורדת spool וכדומה. לפני תחילת העבודה ודא שהתקנת Zowe CLI והפלאגינים (ראה חלק התקנה).

### Zowe CLI - שימוש אינטראקטיבי

בקטע זה נשתמש ב-Zowe CLI אינטראקטיבית כדי לצפות בחברי data set, להגיש jobs ולבדוק spool.

1. ב-VS Code פתח את הטרמינל (Terminal -> New Terminal). הרץ:

```bash
zowe --version
```

לבדיקה שה-CLI מותקן. אם לא, התקן לפי ההוראות בסעיף ההתקנה. שים לב שה-shell המומלץ הוא `bash` או `cmd`.

![zowe --version בטרמינל VS Code](Images/zowe/zowe-cli-version.png "zowe --version")

*איור 26. בדיקת גרסת Zowe CLI*

2. כדי שה-CLI יתקשר עם z/OSMF יש לשמור פרטי חיבור (host, port, user, password וכו'). אם כבר יש תיקיית תצורה של הצוות, בצע `cd` אליה והריץ:

```bash
zowe config list --locations
```

![רשימת קונפיגים של צוות Zowe CLI](Images/zowe/list-team-config.png "zowe config list --locations")

*איור 27. הצגת מיקומי קונפיגורציה של Zowe CLI*

3. בדוק חיבור ל-z/OSMF:

```bash
zowe zosmf check status
```

4. רשום data sets תחת מזהה המשתמש שלך:

```bash
zowe files list ds "Z99998.*"
```

או רשום את כל המקרים (members) ב-PDS:

```bash
zowe files list am "Z99998.CBL"
```

![פקודות zowe files list ds ו-am](Images/zowe/zowe-files-list-ds-and-am-commands.png "zowe files list ds/am")

*איור 28. דוגמאות לפקודות list של Zowe CLI*

5. הורד לחומרה המקומית חברי CBL ו-JCL:

```bash
zowe files download am "Z99998.CBL" -e ".cbl"
zowe files download am "Z99998.JCL" -e ".jcl"
```

![הורדת חברי data set בעזרת CLI](Images/zowe/zowe-files-download-am.png "zowe files download am")

*איור 29. הורדת חברי data set*

6. הגש את ה-JCL למשל `Z99998.JCL(HELLO)` והמתין לתוצאה, למשל:

```bash
zowe jobs submit ds "Z99998.JCL(HELLO)" --vasc
```

או כדי לחכות לסטטוס OUTPUT:

```bash
zowe jobs submit ds "Z99998.JCL(HELLO)" --wfo
```

כדי להציג רשימת spool files של job:

```bash
zowe jobs list sfbj JOB04064
```

ולצפייה בספציפי:

```bash
zowe jobs view sfbi JOB04064 105
```

![דוגמאות לפקודות submit/list/view של Zowe jobs](Images/zowe/zowe-jobs-submit-ds-and-view-spool-output.png "zowe jobs submit / list / view")

*איור 30. שליחת job וצפייה בספול*

ניתן גם להגיש וליישם הורדה של spool יחד באמצעות `-d .`:

```bash
zowe jobs submit ds "Z99998.JCL(HELLO)" -d .
```

![הגשת job והורדת ספול](Images/zowe/zowe-jobs-submit-ds-and-download-spool-output.png "submit and download spool")

*איור 31. הגשה והורדת spool*

ה-CLI תומך ב-`--rfj` לקבלת פלט בתצורת JSON לשימוש בתסריטים.

```bash
zowe jobs submit ds "Z99998.JCL(HELLO)" --rfj
```

![דוגמא לשימוש בדגל --rfj לקבלת JSON](Images/zowe/zowe-jobs-submit-ds-rfj.png "--rfj לקבלת JSON")

*איור 32. `--rfj` — פלט JSON*

### Zowe CLI - שימוש פרוגרמטי

כעת נראה דוגמה לאוטומציה פשוטה באמצעות Node/npm. ניצור פרויקט Node קטן (npm init) בתיקייה של הפרויקט ואחר כך נוסיף סקריפט ב-`package.json` שמריץ את פקודת Zowe הזו:

```bash
zowe jobs submit ds 'Z99998.JCL(HELLO)' -d .
```

החלף `Z99998` במזהה המשתמש שלך. ראה דוגמה ב-`npm init` וביצוע `npm run clg`.

![דוגמא ל-npm init ו-package.json עם סקריפט clg](Images/npm/npm-init-example.png "npm init")

*איור 33. יצירת package.json באמצעות npm init*

ניתן גם להוסיף כפתור ב-VS Code שיקרא את הסקריפט (`npm run clg`) — אפשרות נוחה להרצה גרפית.

![כפתור ב-VS Code להרצת הסקריפט](Images/npm/npm-run-clg-button.png "הוספת כפתור להרצת npm run clg")

*איור 35. `clg` מופעל דרך כפתור ב-VS Code*

\newpage

## Data division

הבנת משתני COBOL ועיבודם היא חיונית ללמידת השפה. מתכנת COBOL מנוסה חייב לשלוט במאפייני משתני COBOL ובעבודה עם המשתנים. מטרת פרק זה היא להציג את יסודות משתני COBOL ולהיחשף לאופציות מתקדמות רבות.

הפרק הבא כולל מעבדה שבה תוכל לקמפל ולהריץ דוגמאות בקוד. לאחר קומפילציה מוצלחת של תוכנית אחת, תוצג תוכנית נוספת עם שגיאה משולבת הממחישה כיצד לאתר ולתקן שגיאות הקשורות לסוגי נתונים ו-PICTURE.

- **משתנים / Data-items**

   - **מגבלות על שמות משתנים וסוגי נתונים**

- **PICTURE clause**

   - **סמני PIC וסוגי נתונים**

   - **קידוד שמות משתנים / data-items**

   - **ייצוג מחרוזת של PIC**

- **Literals**

   - **Figurative constants**

   - **קשרי נתונים**

   - **רמות של נתונים**

- **MOVE and COMPUTE**

- **מעבדה**

## Variables / Data-items

משתנה ב-COBOL, המכונה גם data item, הוא שם שנבחר על-ידי המתכנת. משתנה זה מקדיש מקום בזיכרון לאחסון ערכים משתנים. לשמות משתנים יש כללים וחוקים שיש להקפיד עליהם.

### Variable / Data-item name restrictions and data types

חוקים עיקריים לשמות משתנים ב-COBOL:

- אסור שיהיה שם שמור של COBOL.
- אסור לכלול רווח בשם.
- מורשה להשתמש באותיות A-Z, ספרות 0-9, קו תחתון '_' ומקף '-'.
- אורך מקסימלי 30 תווים.
- מקף לא יכול להיות התו הראשון או האחרון.
- קו תחתון לא יכול להיות התו הראשון.

בעת קומפילציה הקומפיילר מצפה לתיאור מאפיינים עבור כל משתנה — אורך, סוג נתונים וכו'. נתונים נפוצים:

- Numeric (0-9)
- Alphabetic (A-Z, a-z, מרווח)
- Alphanumeric (שילוב של ספרות ותווים)

## PICTURE clause

מילת השמורה PICTURE (או PIC) מגדירה את אורך וסוג הנתון של משתנה. דוגמאות PIC נפוצות:

- PIC 9 — ספרתי, אורך 1
- PIC 9(4) — ארבע ספרות
- PIC X — אלפאנומרי, אורך 1
- PIC X(4) — ארבעה תווים

### PIC clause symbols and data types

יש סימולי PIC נוספים מעבר ל-9 ו-X, למשל A לאלפבית-only, וסמלים מיוחדים כמו B E G N P S U V Z / + - , . * CR DB וכן סמל מטבע (cs) כמו $.

להרחבה עיין ב-Enterprise COBOL Language Reference (קישור בקובץ המקורי).

### Coding COBOL variable / data-item names

תיאור משתנה נעשה ב-DATA DIVISION בעזרת מספר רמה (level number) ו-PIC clause. מספר הרמה מציין היררכיה בתוך רשומה, והשילוב מגדיר את מבנה הנתונים.

### PICTURE clause character-string representation

חלק מסמני ה-PIC יכולים להופיע פעם אחת ואחרים רבים. דוגמאות:

- `PIC 9(4)V99` מתאים לערכים כמו 1123.45 (V מציין מיקום עשרוני)
- `PIC $9,999V99` מתאים לערכים כספיים עם פסיקים וסימן דולר

## Literals

Literal הוא ערך קבוע שלא משתנה בזמן הריצה. לדוגמה: `DISPLAY "HELLO WORLD!"` — כאן "HELLO WORLD!" הוא literal.

### Figurative constants

דוגמאות: ZERO, ZEROS, SPACE, SPACES, HIGH-VALUE, LOW-VALUE, QUOTE, NULL ועוד.

### Data relationships

מערכות היחסים בין הנתונים מוגדרות ב-DATA DIVISION באמצעות אינדיקטורי רמה (level numbers). רמות מיוחדות הן 66, 77 ו-88 שיש להן התכונות ייחודיות.

#### Level numbers

רמות בין 01 ל-49 וכן רמות מיוחדות 66, 77, 88. קבוצת פריטים (group item) כוללת את כל הפריטים עד להופעת רמת מספר קטנה או שווה לה.

![](Images/image107.png)

*איור 1. יחס היררכי של מספרי רמה*

### Levels of data

לאחר הגדרת רשומה ניתן לחלק אותה לשדות תת-רמתיים. פריטים יסודיים (elementary items) אינם ניתנים לחלוקה ויש להם PIC.

## MOVE and COMPUTE

משפטי MOVE ו-COMPUTE משנים ערכי משתנים. לדוגמה, COMPUTE מאפשר חישובים כגון הגדרת `GROSS-PAY = HOURS * RATE` כאשר המשתנים מתוארים כנתונים מספריים (PIC 9 וכו').

![](Images/image108.png)

*איור 2. דוגמת MOVE ו-COMPUTE*

## Lab

המעבדה כוללת צפייה בקבצי מקור וביצוע JCL לקימפול והרצת תוכניות PAYROL00 ו-PAYROL0X, איתור שגיאות קומפילציה (IGYPA3146-S) ותיקונן. הוראות מפורטות נמצאות בקובץ המקורי ובתמונות המצורפות.

\newpage

# Table handling

החלק הזה מציג טבלאות (מנשאים) ב-COBOL — אוסף פריטים בעלי תיאור זהה (דומה למערכים). פריטי המשנה נקראים table elements. מטרת הפרק היא להסביר כיצד לטפל בטבלאות בתוכניות COBOL.

## Defining a table

דוגמת טבלה ב-COBOL:

```COBOL
01  TABLE-NAME.
    05  SUBORDINATE-NAME OCCURS n TIMES.
      10  ELEMENT1  PIC X(2).
      10  ELEMENT2  PIC 9(2).
```

חלופות ופירוטים נוספים מופיעות בחומר המקורי — כולל טבלאות מרובות ממדים ועד 7 ממדים, וטבלאות משתנות ב-OCCURS DEPENDING ON.

## Referring to an item in a table

ניתן להתייחס לפריט בטבלה באמצעות subscript (מספר הופעה) או index (INDEXED BY). Subscript מתחיל ב-1. ניתן להשתמש בשם נתון כ-subscript אם הוא ספרתי.

דוגמאות ושימושים ב-INDEXED BY וכן שימוש ב-USAGE IS INDEX מסוברים בהרחבה בחומר.

## Loading a table with data

טבלאות ניתן להעמיס דינמית (קובץ/מסך), באמצעות REDEFINES, INITIALIZE, או VALUE clause בהגדרה.

### REDEFINES של ערכים קבועים

דוגמה הממירה מספר שורות מילים לטבלת ערכים באמצעות REDEFINES מוצגת במקור.

### INITIALIZE טבלה

ניתן להשתמש ב-INITIALIZE כדי לאתחל כל הפריטים בטבלה, עם אופציות REPLACING NUMERIC DATA BY וכו'.

### Assigning values using VALUE clause

לדוגמה, הגדרת קבוצת תווים עם VALUE "1234" שמתחילה את אלמנטים של הטבלה.

## Variable-length tables

שימוש ב-OCCURS 1 TO 10 DEPENDING ON Y כדי להגדיר טבלת אורך משתנה. יש לדאוג שחישוב אור הרשומות ותכיפות ה-ODO יהיו תואמים ל-PIC.

## Searching a table

שתי טכניקות: Serial search (SEARCH VARYING) ו-Binary search (SEARCH ALL). SEARCH ALL דורש שהטבלה ממוינת ומוגדרת עם ASCENDING/DESCENDING KEY.

דוגמאות קוד שמורות כפי שהן בקובץ המקורי נשמרות ללא שינוי.

## Lab

המעבדה כוללת הפעלת דוגמאות SRCHSER ו-SRCHBIN, השוואת התוצאות, ותצפית על הבדלי השימוש ב-SEARCH ו-SEARCH ALL.

\newpage

# File handling

הפרק מסביר קריאת רשומות מקבצים רציפים, העתקת שדות פנימיים ל-output וכתיבת קבצי פלט. נלמד כאן את מבנה ENVIRONMENT DIVISION, FILE-CONTROL, FD ותהליך OPEN/READ/WRITE/CLOSE.

## COBOL code used for sequential file handling

דרושות שלוש בחלקות עיקריות:
- ENVIRONMENT DIVISION — SELECT / ASSIGN clauses
- DATA DIVISION — FD statements והגדרת רשומות
- PROCEDURE DIVISION — OPEN, READ, WRITE, CLOSE

### FILE-CONTROL paragraph

ה-FILE-CONTROL מקשר בין שם פנימי של קובץ (SELECT) לשם חיצוני (ASSIGN). ב-FD מוגדר תיאור הרשומה (level numbers, variable names, PIC).

![](Images/image125.png)

*איור 1. FILE-CONTROL*

### COBOL external data source

ב-z/OS יש מגוון שיטות אחסון; בפרק זה נתמקד ב-data sets רציפים (sequential datasets) — אוסף רשומות עם אורך רשומה קבוע.

### Data sets, records, and fields

Dataset מכיל רשומות; רשומה כוללת שדות שביחד מהווים את אורכה. לעתים משתמשים בחסימת רשומות (blocking) כדי לשפר ביצועים (BLOCK CONTAINS).

![](Images/image127.png)

*איור 3. רשומות, שדות וחסימות*

### ASSIGN clause

SELECT ACCT-REC ASSIGN TO ACCTREC יוצר קשר בין שם פנימי ACCT-REC ל-DDNAME ב-JCL שנקרא ACCTREC. ב-JCL נשתמש ב-`//ACCTREC DD DSN=MY.DATA,DISP=SHR` כדי להפנות את הקובץ.

קשר זה מאפשר גמישות — להחליף את מקורות הנתונים בלי לשנות קוד COBOL, רק לשנות את ה-JCL.

## PROCEDURE DIVISION sequential file handling

לפני קריאת או כתיבת קבצים יש לפתוח את הקבצים (OPEN INPUT/OUTPUT). אם ASSIGN לא מקושר ל-DDNAME ב-JCL, תקבל שגיאת זמן ריצה בעת ה-OPEN.

### Open input and output for read and write

לדוגמה: OPEN INPUT ACCT-REC, OPEN OUTPUT PRINT-LINE.

![](Images/image128.png)

*איור 4. OPEN-FILES*

### Close input and output

בסיום יש לסגור קבצים: CLOSE ACCT-REC, CLOSE PRINT-LINE ואז STOP RUN.

![](Images/image129.png)

*איור 5. CLOSE-STOP*

## COBOL programming techniques to read and write records sequentially

טכניקת קידוד נפוצה היא להשתמש ב-PERFORM UNTIL כדי לבצע READ ולכתוב את הרשומות עד לסוף הקובץ. מבנה טיפוסי כולל פסקאות: READ-NEXT-RECORD, READ-RECORD, WRITE-RECORD, CLOSE-STOP.

![](Images/image130.png)

*איור 6. קריאה וכתיבה של רשומות*

### READ-NEXT-RECORD paragraph execution

פסקה זו מבצעת PERFORM UNTIL תוך קריאה חוזרת ל-READ-RECORD וכתיבה ל-WRITE-RECORD עד שמזהה END-OF-FILE.

### READ-RECORD paragraph

מכילה את READ ACCT-REC AT END MOVE 'Y' TO LASTREC END-READ. — במקרה של AT END מעדכנים את הדגל LASTREC.

### WRITE-RECORD paragraph

מכילה את פעולות ה-MOVE ליצירת רשומת פלט ואז את WRITE PRINT-REC.

![](Images/image131.png)

*איור 7. Iterative processing*

## Lab

המעבדה מתמקדת בשיטות end-of-file למילוי כל הרשומות מקובץ רציף — כולל שלבים של זיהוי שגיאות קומפילציה ו-ABEND, תיקונים והמצאים המתקבלים.

הוראות מפורטות לגבי הרצת קבצים CBL0001, CBL0002, CBL0003 ו-JCL המתאימים נמצאות בקובץ המקורי.

\newpage

# Program structure

פרק זה דן בתכנות מובנה (structured programming) ואיך זה מתבטא ב-COBOL — שימוש ב-PERFORM, הגבלת GO TO, פסקאות ותכנון מבנה ה-PROCEDURE DIVISION.

- סגנונות תכנות: Structured vs OO
- מבנה Procedure Division
- Paragraphs as blocks of code
- Program control with paragraphs
- שימוש בתתי-תוכניות (subprograms) ו-copybooks

## Styles of programming

COBOL היא שפת תכנות מובנית; למרות שקיימת אפשרות לכתוב קוד לא-מסודר (spaghetti) עם GO TO, יש להעדיף שימוש ב-PERFORM ופסקאות כדי לשמור על קריאות.

### What is structured programming

תכנות מובנה משתמש בבניינים של שליטה (לופים, פונקציות) על מנת להפוך קוד קריא ותחזוקי.

### What is Object Orientated Programming

OO מבוסס על מחלקות, משתנים ומתודות; ניתן לכתוב COBOL באופן מונחה-עצמים, אך זה אינו נפוץ בקומפוננטות הממשיות המתחברות ל-middleware ישן.

### COBOL programming style

במקום for/while ו-funcions, COBOL משתמש ב-PERFORM ובפסקאות ליצירת מבנה.

## Structure of the Procedure Division

הרצת תוכנית מתחילה במשפט הראשון ב-PROCEDURE DIVISION וממשיכה בקו עד לסיום. כדי להימנע מחזרתיות משתמשים ב-PERFORM, CALL ו-CALL THRU.

### Program control and flow through a basic program

דוגמאות שמראות שימוש ב-PERFORM כדי להוציא קוד חזרתי לקובץ פלט, ובשימוש ב-PERFORM VARYING כדי להקים לולאה.

### Inline and out of line perform statements

PERFORM יכול לקפוץ לפסקה חיצונית (out of line) או לרוץ inline; לאחר קיום הפסקה מתבצעת חזרה לשורה שאחרי ה-PERFORM.

### Using performs to code a loop

דוגמא של PERFORM VARYING COUNTER FROM 01 BY 1 UNTIL COUNTER EQUAL 11 מאפשרת לכתוב לולאה ברורה וקריאה.

### Learning bad behavior using the GO TO keyword

GO TO יווצר זרימת שליטה שאינה חוזרת ונגרמת ABEND (IGZ0037S) אם הזרימה תמשיך מעבר לשורות הקוד. יש להשתמש ב-GO TO רק לאחר הבנה מדוקדקת של השפעותיו.

## Paragraphs as blocks of code

פסקה ב-COBOL דומה לפונקציה ללא פרמטרים. מומלץ לתת לפסקאות שמות ברורים, לארגן פסקאות לפי סדר ריצה ולהשתמש בסוף פסקה מרמז (PARAGRAPH-END) אם רצוי.

### Designing the content of a paragraph

מטרות: לקבץ רצף משפטים לפונקציונליות ברורה או להשתמש בפסקה כחלק מלולאה.

### Order and naming of paragraphs

טכניקות נפוצות: שמות ברורים, מספרי פסקאות עולה (1000-OPEN-FILES וכו') ושימוש בפסקת סיום נקייה (1000-END) כגבול ויזואלי.

### Program control with paragraphs

סוגי PERFORM: PERFORM TIMES, PERFORM THROUGH/THRU, PERFORM UNTIL, PERFORM VARYING — כולם מאפשרים שליטה על ריצות חוזרות של פסקאות.

### Using subprograms

קוד משותף ניתן למקם בתוכניות נפרדות ולקרוא להן באמצעות CALL 'PROG' USING ... RETURNING ...; תמיכה ב-BY REFERENCE, BY CONTENT, BY VALUE (BY VALUE משמש בעיקר לקריאות לשפות אחרות כמו C).

### Using copybooks

COPY מאפשר לכלול קטעי קוד מובנים במהלך קומפילציה. יש לספק SYSLIB ב-JCL כדי לציין את ספריות ה-copybooks.

## Summary

הפרק מסכם את רעיונות התכנות המובנה ב-COBOL, שימוש יעיל ב-PERFORM, תכנון פסקאות, וקריאות לתת-תוכניות.

## Lab

מעבדה מבוססת CBL0033 ומאפשרת להשוות דפוסי PERFORM שונים ולקרוא תוכנית فرعية HELLO.

\newpage

# File output

נלמד עיצוב דוחות ופלטים — כותרות, ריווחים (FILLER), פורמטים מספריים ומטבעיים, וכתיבת שורות באמצעות PRINT-REC ו-PRINT-REC FROM.

### ENVIRONMENT DIVISION

חזרה על SELECT ו-ASSIGN עבור קבצי פלט כמו PRINT-LINE.

![](Images/image141.png)

*איור 1. SELECT ו-ASSIGN*

### FILE DESCRIPTOR

FD מתאר את פריסת קובץ התפוקה (PRINT-LINE). FILLER שימושי ליצירת ריווחים ללא שמות של שדות.

![](Images/image142.png)

*איור 2. FILLER*

### Report and column headers

תכנון מבנה פלט כולל HEADER-1 .. HEADER-4 המגדירים כותרות וקווים מפרידים. CURRENT-DATE משמש לאחזור תאריכים למלא HEADER-2.

![](Images/image143.png)

*איור 3. מבנה דוח מותאם*

### PROCEDURE DIVISION

לכתיבת הכותרות משתמשים ב-MOVE ו-PRINT-REC FROM כדי להעביר את תוכן האזורים ל-line המיועד ולכתוב אותו בפועל.

## Lab

מעבדה עם CBL0004 ו-CBL0005: שלח את JCL וצפה בדוח; תרגיל להוסיף סימן מטבע לדו"ח.

\newpage

# Conditional expressions

נבחן כיצד תוכניות מקבלות החלטות ב-PROCEDURE DIVISION: IF, EVALUATE, PERFORM, SEARCH; סוגי תנאים: relation, class, sign; אופרטורים לוגיים AND/OR.

## Boolean logic, operators, operands, and identifiers

תנאים מבוססים על הגיון בוליאני (true/false). ביטוי פשוט: `IF LANGUAGE = "COBOL" THEN DISPLAY ...`.

### COBOL conditional expressions and operators

סוגים עיקריים: relation condition, class condition, sign condition. תמונת טבלה של אופרטורים במקור.

### Examples of conditional expressions using Boolean operators

דוגמאות IF עם AND/OR מצוינות במקור.

## Conditional expression reserved words and terminology

מילות שמורה נפוצות: IF, EVALUATE, PERFORM, SEARCH. Conditional names (88-level) משמשים לשיפור קריאות הקוד.

### IF, EVALUATE, PERFORM and SEARCH

הסבר על מבני IF/ELSE/END-IF, EVALUATE (מחליף עבור מספר רב של תנאים), PERFORM UNTIL ו-SEARCH.

### Conditional states and names

שימוש ב-88-level מאפשר להגדיר שמות תנאים כמו:

```COBOL
01 USA-STATE PIC X(2).
   88 STATE VALUE 'TX'.
```

ואז להשתמש ב-IF STATE DISPLAY ...

## Conditional operators

טבלת אופרטורים יחסיים במקור מציגה צורות שונות לקריאה כמו IS GREATER THAN, IS NOT < ועוד.

## Conditional expressions

### IF ELSE (THEN) statements

מבנה IF ... ELSE ... END-IF — THEN אופציונלי. IF מסיים ב-END-IF במבנה מודרני.

### EVALUATE statements

חלופה לשרשר IF-ים: מאפשרת WHEN מרובים וסיום ב-END-EVALUATE.

### PERFORM statements

PERFORM UNTIL CONDITION — מבצע פסקאות עד שהמצב מתקיים; ניתן להשתמש ב-88-level לשפר קריאות.

### SEARCH statements

SEARCH ו-SEARCH ALL לחיפוש בטבלאות — שימוש ב-WHEN להצביע על מקרה נמצא או AT END.

## Conditions

פירוט של Relation, Class ו-Sign conditions — מידע נוסף בקישורים של IBM.

## Lab

מעבדות עם CBL0006 ו-CBL0007 מציגות בדיקות תנאים, זיהוי הודעות שגיאה (IGYPS2113-E) ותיקונים.

\newpage

# Case Sensitive Nature of COBOL Conditions

תחביר ה‑COBOL אינו תלוי ב‑case עבור מילות מפתח וזיהוי שמות, אך השוואת מחרוזות בתנאים היא תלויה‑case. ההבחנה הזו בין תחביר השפה לבין השוואת נתונים יכולה לגרום לשגיאות לוגיות שקשה לגלות כאשר התוכנית מקבלת קלט חיצוני או משוחחת עם מערכות צד שלישי.

למה זה חשוב?

שגיאות של case-sensitivity נוטות לעבור את שלבי הקומפילציה והריצה הראשוניים מבלי להתגלות — כלומר התוכנית "רץ ללא שגיאות" אך מספק תוצאות לא נכונות. בעיות מסוג זה יכולות לגרום ל:

- דוחות שגויים או חסרים ערכים
- מסלולי לוגיקה שלא נוצרים כראוי (לדוגמה, בלוקי IF שלא מתבצעים)
- נתונים שמסולקים או מנותבים לא נכון

דוגמה מעשית

המשפטים הבאים שקולים מבחינת התחביר של COBOL:
`MOVE MY-NUMBER TO YOUR-NUMBER` ו־`Move my-Number to your-Number` — כי מילות המפתח והזיהויים אינם תלויות case.

אולם בהשוואת מחרוזות בתוך תנאי המצב שונה:

`IF USA-STATE = 'new York'` — תנאי זה יכשל (Mismatch בשל case)

`IF USA-STATE = 'New York'` — תנאי זה יצליח אם הערך המדויק תואם את ה‑case

ההשוואה כושלת בצורה שקטה — COBOL לא זורקת שגיאה, אך התוצאה הלוגית שונה.

מעבדה קצרה

בתרגיל זה תחקור/program שבו סופרים לקוחות מ"New York" אך התוצאה חוזרת אפס למרות שיש רשומות מתאימות בקובץ הקלט.

קבצים נדרשים:

- `CBL006A.cobol` — קוד התוכנית
- `CBL006AJ.jcl` — JCL לביצוע
- `id.DATA` — קובץ הקלט

הוראות קצרות:
1. פתח את `CBL006A.cobol` וראה היכן נעשית השוואת המדינה (IF ... = 'New York').
2. הגש את `CBL006AJ.jcl` וצפה בתוצאת הדו"ח; בדוק האם ה‑count מראה אפס למרות הציפיה.
3. בדוק את ה‑case של השדה מהקובץ `id.DATA` והשווה אותו לליטרל שבקוד. עדכן את הליטרל כדי להתאים ל‑case המדויק (או השתמש בפונקציה להעברה ל‑UPPER-CASE/LOWER-CASE לפני ההשוואה).
4. שמור, קמפל והגש מחדש — הדו"ח אמור להראות: `New York Clients = 005` (בהתאם לדוגמה במקור).

טיפ: כדי להימנע מבעיות case בעת השוואות, מומלץ לנרמל את שני הצדדים של ההשוואה (למשל `FUNCTION UPPER-CASE(USA-STATE) = 'NEW YORK'`).

\newpage

# Arithmetic expressions

פרק זה מכסה ביטויים אריתמטיים, אופרטורים בינאריים/אונריים, תחביר COMPUTE, כללי קדימות, ומגבלות (ARITH(COMPAT/EXTEND)).

### Arithmetic operators

סימנים: + - * / ** (Exponentiation); שימוש ב-COMPUTE מומלץ לחישובים מורכבים.

### Arithmetic statements

ADD, SUBTRACT, MULTIPLY, DIVIDE — אך COMPUTE נוח ויעיל לשילובים.

### Precedence

סדר קדימות: (), unary, **, * / (left-to-right), + - (left-to-right).

### Limitations and operand sizes

תנאי ARITH משפיעים על הגדלים המקסימליים של אופראנדים (18 או 31 ספרות) ו-composite determination לפי הטבלה במקור.

## Examples and Lab

דוגמאות COMPUTE לטרנזאקשנים של סכומים (TLIMIT, TBALANCE) וכתיבת טריילרים בדוח. מעבדות CBL0008/CBL0009 להמחשה ותרגול.

\newpage

# Data types

הסבר על ייצוג נתונים פנימי: COMP-1, COMP-2, COMP-3 (packed decimal), COMP-4, COMP-5; וכן ייצוג טקסט ב-EBCDIC ו-ASCII. הבדל בין DISPLAY ו-COMPUTATIONAL.

### Numerical representations

- COMP-1: floating single precision
- COMP-2: floating double precision
- COMP-3: packed BCD — נפוץ במערכות פיננסיות, מדויק עד 31 ספרות
- COMP-4: integer-packed
- COMP-5: דומה ל-COMP-4 עם מיקום נקודה עשרונית

### Text representations

EBCDIC הוא פורמט ברירת מחדל ב-z/OS; ASCII נפוץ במערכות אחרות — חשוב לייצור המרה כשמחליפים בין סביבות.

## DISPLAY vs COMPUTATIONAL

שדות DISPLAY מיוצגים בטקסט (EBCDIC ברירת מחדל), בעוד שדות PACKED/BINARY/FLOAT משתמשים ב-USAGE COMP-3/COMP-1 וכו'.

## Lab

מעבדה המדגימה ABEND (U4038) שנגרם מחוסר תאימות בין תיאור שדה (COMP-3) לבין הנתונים החיצוניים; תיקון על-ידי הגדרת PIC/COMP-3 נכונה.

\newpage

# Intrinsic functions

COBOL המודרנית כוללת פונקציות פנימיות רבות (Functions) — GROUPS: Mathematical, Statistical, Date/time, Financial, Character-handling, General. דוגמות שימוש ב-FUNCTION UPPER-CASE, MEAN, MEDIAN, ANNUITY, CURRENT-DATE ועוד.

### Syntax

`FUNCTION function-name(argument)` — מחזירה ערך זמני שניתן להשתמש בו ב-MOVE/COMPUTE/DISPLAY.

### Categories and examples

- Mathematical: FUNCTION SUM
- Statistical: MEAN, MEDIAN, RANGE
- Date/time: CURRENT-DATE, INTEGER-OF-DATE, DATE-OF-INTEGER
- Financial: ANNUITY
- Character-handling: UPPER-CASE, LOWER-CASE

### Reference modification

LNAME(1:1) מחזיר את התו הראשון; שימוש בשילוב עם פונקציות מאפשר שינוי פורמט שמות (כמו Capitalize).

## Lab

הדגמה פרקטית של שימוש ב-FUNCTION LOWER-CASE עם reference modification כדי להציג שם משפחה עם אות ראשונה גדולה ושאר התווים קטנים; טיפול בשגיאות תחביריות ב-CBL0012.

\newpage

# ABEND handling

כאשר הרצת את המעבדות בפרקים הקודמים יתכן שנתקלת ב‑ABEND (קיצור ל"abnormal end"). קיימים סוגים שונים של שגיאות COBOL שיכולות לגרום ל‑ABEND, ובסביבת ייצור שגיאות אלה עלולות להיות יקרות — הן מבחינה כספית והן מבחינת מוניטין.

פרק זה מציג את ה‑ABEND ומספק סקירה של סוגי ה‑ABEND הנפוצים שמשתמש COBOL עלול להיתקל בהם. נדון בסיבות אפשריות, בסיבות החוזרות של כל קוד ABEND, ונסקור שיטות מומלצות להפחתת ההתרחשות של ABEND. בנוסף, נראה דוגמאות כאשר כדאי לקרוא לשגרת ABEND באופן מכוון מתוך היישום.

- **Why does ABEND happen?**

- **Frequent ABEND Types**

    - **S001 - Record Length / Block Size Discrepancy**

    - **S013 - Conflicting DCB Parameters**

    - **S0C1 - Invalid Instruction**

    - **S0C4 - Storage Protection Exception**

    - **S0C7 - Data Exception**

    - **S0CB - Division by Zero**

    - **S222/S322 - Time Out / Job Cancelled**

    - **S806 - Module Not Found**

    - **B37/D37/E37 - Dataset or PDS Index Space Exceeded**

- **Best Practices to Avoid ABEND**

- **ABEND Routines**


## Why does ABEND happen?

בשונה ממחשב עבודה מקומי, ה‑mainframe משתמש בארכיטקטורת הוראות שנקראת z/Architecture. ארכיטקטורת הוראות זו מגדירה אילו הוראות מכונה מותרות להתבצע ברמת הקוד הנמוכה.

אם המערכת מנסה לבצע הוראה שאינה חוקית או המערכת מזהה מצב גישה לזיכרון לא תקין, תתרחש הפסקה לא תקינה (ABEND). זה יכול לקרות בזמן קומפילציה, בזמן הקישור (link-edit), או בזמן הריצה של תוכנית COBOL.


## Frequent ABEND Types

להלן רשימה של קודי ABEND נפוצים והגדרה קצרה של כל אחד:

- **S001** - Record Length / Block Size Discrepancy
- **S013** - Conflicting DCB Parameters
- **S0C1** - Invalid Instruction
- **S0C4** - Storage Protection Exception
- **S0C7** - Data Exception
- **S0CB** - Division by Zero
- **S222/S322** - Time Out / Job Cancelled
- **S806** - Module Not Found
- **B37/D37/E37** - Dataset or PDS Index Space Exceeded

לעתים קוד ה‑ABEND מופיע עם reason code נוסף שמסייע לצמצם את הגורם המדויק. בהמשך בכל קטגוריה מופיעים כמה cause/ reason נפוצים ודוגמאות.

### S001 - Record Length / Block Size Discrepancy

ב‑z/OS מאוחסנים נתונים ב‑data sets — קובצים המורכבים מרשומות. לכל data set מוגדר אורך רשומה (record length) ו‑block size בעת יצירתו. אי‑התאמה בין התיאורים (בין תוכנית ה‑COBOL, ה‑JCL או ההגדרה של ה‑dataset) היא סיבה נפוצה ל‑S001.

**Reason Codes:**
- S001-0: קונפליקט בין הגדרת אורך הרשומה (תוכנית מול JCL מול תווית dataset)
- S001-2: מדיה פגומה או שגיאת אחסון
- S001-3: שגיאת QSAM קריטית
- S001-4: קונפליקט בהגדרות ה‑block (תוכנית מול JCL)
- S001-5: ניסיון לקרוא מעבר לסוף הקובץ (read past end-of-file)

**Frequent Causes:**
- S001-0: טעות הקלדה ב‑FD או ב‑JCL
- S001-2: dataset פגום
- S001-3: בעיה פנימית ב‑z/OS
- S001-4: שכחת לקודד BLOCK CONTAINS 0 RECORDS ב‑FD
- S001-5: שגיאת לוגיקה בתוכנית

### S013 - Conflicting DCB Parameters

S013 מתרחש כאשר התוכנית מצפה של‑DD תהיה DCB מסוימת אך ה‑DD בפועל מכיל DCB שונה (למשל block size, record length או record format שונים).

למידע נוסף על data sets עיין בתיעוד IBM Knowledge Center (קישור במקור).

**Reason Codes:**
- S013-10: dummy data set זקוק ל‑buffer space; יש לציין BLKSIZE ב‑JCL
- S013-14: DD statement חייב לציין PDS
- S013-18: PDS member לא נמצא
- S013-1C: שגיאת I/O בחיפוש בתיקיית ה‑PDS
- S013-20: block size אינו כפולה של אורח הרשומה
- S013-34: אורך הרשומה שגוי
- S013-50: ניסיון לפתוח מדפסת כקובץ קלט
- S013-60: block size לא שווה לאורך הרשומה כאשר מדובר בגודל לא מוקף
- S013-64: ניסיון לבצע dummy על קובץ indexed או relative
- S013-68: block size גדול מ‑32752
- S013-A4: SYSIN או SYSOUT אינו קובץ QSAM
- S013-A8: פורמט רשומה לא חוקי עבור SYSIN או SYSOUT
- S013-D0: ניסיון להגדיר PDS עם פורמט FBS או FS
- S013-E4: ניסיון לצרף יותר מ‑16 PDSs

**Frequent Causes:**
רוב המקרים נובעים מחוסר תאימות בין ההגדרות ב‑JCL לבין תיאור הקובץ בתוכנית ה‑COBOL.

### S0C1 - Invalid Instruction

ב‑S0C1 המעבד מנסה לבצע הוראה שהיא לא חוקית או שלא נתמכת.

**Reasons:**
- SYSOUT DD statement חסר
- הערך ב‑AFTER ADVANCING קטן מ‑0 או גדול מ‑99
- אינדקס או subscript מחוץ לטווח
- ניתנה פקודת I/O נגד dataset שלא נפתח
- CALL לקישור שלא מתאים להגדרת הקריאה

**Frequent Causes:**
- לוגיקה שגויה בהגדרת AFTER ADVANCING
- לוגיקה שגויה בקוד טיפול בטבלאות או overflow של רשומות בטבלה

### S0C4 - Storage Protection Exception

בעת ריצה z/OS מייעדת address space — בלוק וירטואלי של זיכרון עבור התוכנית. S0C4 מתרחש כאשר התוכנית מנסה לגשת לכתובת זיכרון שנמצאת מחוץ לכתובות שהוקצו לה.

**Frequent Causes:**
- DD statement ב‑JCL חסר או לא נכון
- לוגיקה שגויה בטיפול בטבלאות (index overflow)
- INITIALIZE על FD שלא נפתח

### S0C7 - Data Exception

כפי שנדון קודם, PIC clauses מגדירים סוגי נתונים. S0C7 מתרחש כאשר הקוד מצפה לערך מספרי אך מוצא נתונים לא‑מספריים (לדוגמה ניסיון לבצע חישוב על שדה שמכיל תווים).

**Frequent Causes:**
- משתנים שלא אתחלתם כראוי
- חוסר ב‑data edits
- MOVE משדה קצר לשדה ארוך ברמת 01 ללא טיפול
- שימוש שגוי ב‑MOVE CORRESPONDING
- שגיאות בהקצאות ומשיכות בין שדות

## Lab

**Handling ABEND S0C7 - Data Exception**

**מטרה:** ללמוד לזהות ולפתור ABEND מסוג S0C7 שנגרם מביצוע חישוב על נתונים לא‑מספריים.

### What is S0C7?

S0C7 הוא שגיאת ריצה (ABEND) המתרחשת כאשר מנסים לבצע אריתמטיקה על נתונים לא‑מספריים.

הודעת שגיאה טיפוסית:

`CEE3207S The system detected a data exception (System Completion Code=0C7)`

### Why does this error happen?

שדות מספריים מוצהרים כ‑PIC 9 או COMP-3. אם השדה מכיל תווים (אותיות/סמלים) ונעשה עליו חישוב — יתרחש S0C7.

### Here's a simple example:

```
01 JUNK-FIELD      PIC X(05) VALUE "ABCDE".
01 NUM-FIELD-BAD   REDEFINES JUNK-FIELD PIC S9(05) COMP-3.
...
ADD 100 TO NUM-FIELD-BAD.

```

- "ABCDE" אינו מספר.
- `NUM-FIELD-BAD` מוגדר כ‑packed decimal (COMP-3), וכך נוצרת אי‑התאמה שגורמת לקריסה.

### Instructions
1. פתח את `CBL0014.cobol` ונתח את הקוד. שים לב לשימוש ב‑REDEFINES לטיפול בטקסט כשדה מספרי.
2. בדוק את הערך שהוקצה ל‑`JUNK-FIELD` — הוא "ABCDE" ולא חוקי לשדה מספרי.
3. הגש את ה‑JCL `CBL0014J.jcl` ותבחין שהמשימה נכשלה עם S0C7 ABEND.

![](Images/image014.png)

### How to Fix It

למניעת ה־ABEND יש לתקן את התיאור כך שהשדה יהיה מוכלל כטקסט שמומר למספר תקין או לאתחל אותו בערך מספרי תקין. דוגמה מתוקנת:

```
      IDENTIFICATION DIVISION.
      PROGRAM-ID. CBL0014.
      DATA DIVISION.
      WORKING-STORAGE SECTION.
      01 TEXT-FIELD PIC X(05) VALUE "00012".
      01 NUM-FIELD PIC 9(05).
      01 RESULT PIC 9(06).
      PROCEDURE DIVISION.
         DISPLAY "Moving text to numeric field...".
         MOVE TEXT-FIELD TO NUM-FIELD.
         DISPLAY "Performing calculation...".
         ADD 100 TO NUM-FIELD GIVING RESULT.
         DISPLAY "Result: " RESULT.
         STOP RUN.
```

שמור את `CBL0014.cobol` וגש שנית ב‑`CBL0014J.jcl` — התוכנית צריכה לרוץ בהצלחה ולהציג את התוצאה.

![](Images/image014j.png)

### S0CB - Division by Zero

חילוק באפס ב‑COBOL מוביל ל‑ABEND S0CB.

**Reason:** ניסיון לחלק בערך 0.

**Frequent Causes:**
- משתנים שלא אתחלתם
- חוסר בדיקות קלט (data edits)

##  Lab 

**Handling ABEND S0CB - Division by Zero**

**מטרה:** לזהות ולתקן ABEND מסוג S0CB שנגרם מחילוק באפס.

### Instructions
1. פתח את `CBL0013.cobol`. שים לב לשורה שמבצעת חלוקה.

![](Images/image0068.png)

2. ב־`CBL0013.cobol` שים לב ש‑DENOMINATOR מאותחל ל‑0 — זה גורם לחלוקה באפס.
3. הגש את `CBL0013J.jcl` — תראה S0CB ABEND.

![](Images/image0067.png)

4. תקן את הבעיה על‑ידי אתחול DENOMINATOR לערך שאינו אפס, לדוגמה:

`01 DENOMINATOR PIC 9(04) VALUE 10.`

5. שמור והגש שנית — כעת התוכנית תושלם בהצלחה.

![](Images/image0069.png)

### S222/S322 - Time Out / Job Cancelled

כאשר מגישים JCL אפשר לקבוע משך זמן מקצה לעבודה; אם העבודה חורגת מהזמן המוקצע היא עלולה להסתיים ב‑timeout או לבוטל ידנית.

**Reason:** timeout, לרוב עקב לולאה אין‑סופית או לוגיקה שגויה.

**Frequent Causes:**
- לוגיקה לא נכונה
- לולאות שלא מסתיימות (infinite loop)
- פירמוט EOF שגוי
- subscript קטן מדי
- PERFORM THRU/UNTIL בלי שינוי בדגל ה‑EOF

### S806 - Module Not Found

אם קוראים ל‑CALL למודול ו‑JCL לא מציין את ספריית ה‑load המכילה את המודול, המערכת תחפש בספריות המערכת ואז תיכשל.

**Reason:** נעשה CALL למודול שלא נמצא.

**Frequent Causes:**
- המודול נמחק מהספריה
- שם המודול שגוי
- ספריית ה‑load לא צוינה ב‑JCL
- שגיאת I/O בחיפוש בספריית ה‑load

### B37/D37/E37 - Dataset or PDS Index Space Exceeded

תקלות הקשורות למקום בדיסק. כאשר dataset ממלא את המרחב שהוקצה, לא ניתן להוסיף עוד נתונים.

**Reason Codes:**
- B37 - דיסק במערכת רוקן ממקום
- D37 - primary space נגמר ו‑no secondary extents הוגדרו
- E37 - primary ו‑secondary מלאים
- E37-04 - טבלת ה‑volume של דיסקים מלאה

**Frequent Causes:**
- לא הוקצה מספיק מקום לפלט
- לולאת כתיבה אין‑סופית

## Best Practices to Avoid ABEND

שיטות המפחיתות את הסיכון ל‑ABEND ("defensive programming"):

- INITIALIZE שדות בתחילת שגרה — אך יש לשים לב שלא לאתחל דגלים או מצביעים שצריכים לשמר ערכים
- בדיקות I/O — השתמש ב‑FILE STATUS ובדוק לפני המשך בעיבוד
- בדיקות לשדות מספריים לפני חישוב — השתמש ב‑ON OVERFLOW ו‑ON SIZE ERROR
- טיפול נכון בעובי וסגירת טווחים (END-IF, END-PERFORM)
- פורמט קוד עקבי לקריאות תחזוקה
- בדיקות יחידה, בדיקות אינטגרציה וביקורות קוד (peer-review)

## ABEND Routines

לעיתים תרצה לקרוא לשגרת ABEND מתוך היישום כדי לדווח על מצב חמור או לטפל בקלט לא תקין. הארגון שלך בדרך כלל יספק רוטינות כאלה. דוגמה פשוטה:

```COBOL
IF abend-condition
   PERFORM ABEND-ROUTINE.
...
ABEND-ROUTINE.
   DISPLAY "Invalid data".
   STOP RUN.
```

שגרה כזו יכולה להדפיס מידע מפורט שיעזור לאתר היכן ולמה התוכנית נכשלת.

